import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';
import { AccountBalance, AccountPosition } from '../types/DataTypes';

export interface ExportOptions {
  filename?: string;
  includeTimestamp?: boolean;
  includeMetadata?: boolean;
  format?: 'csv' | 'excel' | 'json';
}

export interface ExportMetadata {
  exportDate: string;
  totalRecords: number;
  dataType: string;
  source: string;
  version: string;
}

// Export formats enum
export enum ExportFormat {
  CSV = 'csv',
  EXCEL = 'excel',
  JSON = 'json'
}

// CSV Export Functions
export const exportToCSV = (
  data: any[],
  options: ExportOptions = {}
): void => {
  try {
    if (!data || data.length === 0) {
      throw new Error('No data to export');
    }

    const {
      filename = 'financial_data',
      includeTimestamp = true,
      includeMetadata = false
    } = options;

    // Get headers from the first data item
    const headers = Object.keys(data[0]);

    // Create CSV content
    let csvContent = '';

    // Add metadata header if requested
    if (includeMetadata) {
      const metadata = createExportMetadata(data, 'CSV Export');
      csvContent += `# Export Date: ${metadata.exportDate}\n`;
      csvContent += `# Total Records: ${metadata.totalRecords}\n`;
      csvContent += `# Data Type: ${metadata.dataType}\n`;
      csvContent += `# Generated by: ${metadata.source}\n`;
      csvContent += '\n';
    }

    // Add headers
    csvContent += headers.join(',') + '\n';

    // Add data rows
    data.forEach(row => {
      const values = headers.map(header => {
        const value = row[header];
        // Handle null/undefined values
        if (value === null || value === undefined) {
          return '';
        }
        // Escape commas and quotes in strings
        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
          return `"${value.replace(/"/g, '""')}"`;
        }
        return String(value);
      });
      csvContent += values.join(',') + '\n';
    });

    // Create and download file
    const timestamp = includeTimestamp ? `_${new Date().toISOString().split('T')[0]}` : '';
    const finalFilename = `${filename}${timestamp}.csv`;

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    saveAs(blob, finalFilename);

    console.log(`Exported ${data.length} records to ${finalFilename}`);
  } catch (error) {
    console.error('CSV export failed:', error);
    throw new Error(`Failed to export CSV: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

// Excel Export Functions
export const exportToExcel = (
  data: any[] | { [sheetName: string]: any[] },
  options: ExportOptions = {}
): void => {
  try {
    const {
      filename = 'financial_data',
      includeTimestamp = true,
      includeMetadata = false
    } = options;

    // Create a new workbook
    const workbook = XLSX.utils.book_new();

    // Handle single dataset vs multiple sheets
    if (Array.isArray(data)) {
      if (data.length === 0) {
        throw new Error('No data to export');
      }

      // Single sheet export
      const worksheet = XLSX.utils.json_to_sheet(data);

      // Add metadata if requested
      if (includeMetadata) {
        const metadata = createExportMetadata(data, 'Excel Export');
        // Insert metadata rows at the top
        XLSX.utils.sheet_add_aoa(worksheet, [
          [`Export Date: ${metadata.exportDate}`],
          [`Total Records: ${metadata.totalRecords}`],
          [`Data Type: ${metadata.dataType}`],
          [`Generated by: ${metadata.source}`],
          [] // Empty row separator
        ], { origin: 'A1' });

        // Shift data down
        XLSX.utils.sheet_add_json(worksheet, data, { origin: 'A6', skipHeader: false });
      }

      // Apply basic formatting
      formatExcelWorksheet(worksheet, data);

      XLSX.utils.book_append_sheet(workbook, worksheet, 'Data');
    } else {
      // Multiple sheets export
      const sheetNames = Object.keys(data);
      if (sheetNames.length === 0) {
        throw new Error('No data to export');
      }

      sheetNames.forEach(sheetName => {
        const sheetData = data[sheetName];
        if (sheetData && sheetData.length > 0) {
          const worksheet = XLSX.utils.json_to_sheet(sheetData);

          if (includeMetadata) {
            const metadata = createExportMetadata(sheetData, `Excel Export - ${sheetName}`);
            XLSX.utils.sheet_add_aoa(worksheet, [
              [`Export Date: ${metadata.exportDate}`],
              [`Sheet: ${sheetName}`],
              [`Records: ${metadata.totalRecords}`],
              []
            ], { origin: 'A1' });

            XLSX.utils.sheet_add_json(worksheet, sheetData, { origin: 'A5', skipHeader: false });
          }

          formatExcelWorksheet(worksheet, sheetData);
          XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
        }
      });
    }

    // Generate filename with timestamp
    const timestamp = includeTimestamp ? `_${new Date().toISOString().split('T')[0]}` : '';
    const finalFilename = `${filename}${timestamp}.xlsx`;

    // Write and save file
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    saveAs(blob, finalFilename);

    const totalRecords = Array.isArray(data) ? data.length :
      Object.values(data).reduce((sum, arr) => sum + arr.length, 0);
    console.log(`Exported ${totalRecords} records to ${finalFilename}`);
  } catch (error) {
    console.error('Excel export failed:', error);
    throw new Error(`Failed to export Excel: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

// JSON Export Functions
export const exportToJSON = (
  data: any[],
  options: ExportOptions = {}
): void => {
  try {
    if (!data || data.length === 0) {
      throw new Error('No data to export');
    }

    const {
      filename = 'financial_data',
      includeTimestamp = true,
      includeMetadata = true
    } = options;

    // Create export object
    const exportData: any = {
      data: data
    };

    // Add metadata if requested
    if (includeMetadata) {
      exportData.metadata = createExportMetadata(data, 'JSON Export');
    }

    // Convert to JSON string
    const jsonContent = JSON.stringify(exportData, null, 2);

    // Create and download file
    const timestamp = includeTimestamp ? `_${new Date().toISOString().split('T')[0]}` : '';
    const finalFilename = `${filename}${timestamp}.json`;

    const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
    saveAs(blob, finalFilename);

    console.log(`Exported ${data.length} records to ${finalFilename}`);
  } catch (error) {
    console.error('JSON export failed:', error);
    throw new Error(`Failed to export JSON: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

// Advanced Export Functions
export const exportBalanceDataWithSummary = (
  balanceData: AccountBalance[],
  options: ExportOptions = {}
): void => {
  try {
    if (!balanceData || balanceData.length === 0) {
      throw new Error('No balance data to export');
    }

    // Calculate summary statistics
    const summary = calculateBalanceSummary(balanceData);

    // Create multi-sheet Excel export
    const exportData = {
      'Balance Data': balanceData,
      'Summary': [summary],
      'Account Summary': createAccountSummary(balanceData)
    };

    exportToExcel(exportData, {
      ...options,
      filename: options.filename || 'balance_data_report'
    });
  } catch (error) {
    console.error('Balance data export failed:', error);
    throw error;
  }
};

export const exportPositionsDataWithAnalysis = (
  positionsData: AccountPosition[],
  options: ExportOptions = {}
): void => {
  try {
    if (!positionsData || positionsData.length === 0) {
      throw new Error('No positions data to export');
    }

    // Create analysis data
    const analysis = analyzePositionsData(positionsData);

    // Create multi-sheet Excel export
    const exportData = {
      'Positions Data': positionsData,
      'Security Analysis': analysis.securities,
      'Account Analysis': analysis.accounts,
      'Summary Statistics': [analysis.summary]
    };

    exportToExcel(exportData, {
      ...options,
      filename: options.filename || 'positions_analysis_report'
    });
  } catch (error) {
    console.error('Positions data export failed:', error);
    throw error;
  }
};

// Utility Functions
const createExportMetadata = (data: any[], source: string): ExportMetadata => {
  return {
    exportDate: new Date().toISOString(),
    totalRecords: data.length,
    dataType: detectDataType(data),
    source: `Financial Manager v1.0 - ${source}`,
    version: '1.0.0'
  };
};

const detectDataType = (data: any[]): string => {
  if (!data || data.length === 0) return 'Unknown';

  const firstItem = data[0];
  if ('portfolioValue' in firstItem && 'totalCash' in firstItem) {
    return 'Balance Data';
  }
  if ('symbol' in firstItem && 'marketValue' in firstItem) {
    return 'Positions Data';
  }
  return 'Generic Data';
};

const formatExcelWorksheet = (worksheet: XLSX.WorkSheet, data: any[]): void => {
  if (!data || data.length === 0) return;

  // Auto-size columns (basic implementation)
  const colWidths: number[] = [];
  const headers = Object.keys(data[0]);

  headers.forEach((header, index) => {
    let maxWidth = header.length;
    data.forEach(row => {
      const cellValue = String(row[header] || '');
      maxWidth = Math.max(maxWidth, cellValue.length);
    });
    colWidths[index] = Math.min(maxWidth + 2, 50); // Cap at 50 characters
  });

  worksheet['!cols'] = colWidths.map(width => ({ width }));

  // Format currency columns
  const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
  for (let row = range.s.r + 1; row <= range.e.r; row++) {
    for (let col = range.s.c; col <= range.e.c; col++) {
      const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
      const cell = worksheet[cellAddress];

      if (cell && typeof cell.v === 'number' && headers[col]) {
        const header = headers[col].toLowerCase();
        if (header.includes('value') || header.includes('cash') || header.includes('price')) {
          cell.z = '$#,##0.00'; // Currency format
        }
      }
    }
  }
};

const calculateBalanceSummary = (balanceData: AccountBalance[]) => {
  const totalPortfolio = balanceData.reduce((sum, acc) =>
    sum + (parseFloat(acc.portfolioValue?.toString() || '0') || 0), 0
  );
  const totalCash = balanceData.reduce((sum, acc) =>
    sum + (parseFloat(acc.totalCash?.toString() || '0') || 0), 0
  );
  const avgPortfolio = totalPortfolio / balanceData.length;
  const avgCash = totalCash / balanceData.length;

  return {
    'Total Accounts': balanceData.length,
    'Total Portfolio Value': totalPortfolio,
    'Total Cash': totalCash,
    'Average Portfolio Value': avgPortfolio,
    'Average Cash': avgCash,
    'Cash Percentage': (totalCash / totalPortfolio) * 100,
    'Export Date': new Date().toLocaleDateString()
  };
};

const createAccountSummary = (balanceData: AccountBalance[]) => {
  return balanceData.map(account => {
    const portfolioValue = parseFloat(account.portfolioValue?.toString() || '0') || 0;
    const totalCash = parseFloat(account.totalCash?.toString() || '0') || 0;

    return {
      'Account Number': account.accountNumber,
      'Account Name': account.accountName,
      'Portfolio Value': portfolioValue,
      'Cash Amount': totalCash,
      'Cash Percentage': portfolioValue > 0 ? (totalCash / portfolioValue) * 100 : 0,
      'As of Date': account.asOfBusinessDate
    };
  });
};

const analyzePositionsData = (positionsData: AccountPosition[]) => {
  // Securities analysis
  const securitiesMap = new Map<string, any>();
  const accountsMap = new Map<string, any>();

  positionsData.forEach(position => {
    const symbol = position.symbol;
    const accountNumber = position.accountNumber;
    const marketValue = parseFloat(position.marketValue?.toString() || '0') || 0;
    const shares = parseFloat(position.numberOfShares?.toString() || '0') || 0;

    // Securities analysis
    if (!securitiesMap.has(symbol)) {
      securitiesMap.set(symbol, {
        Symbol: symbol,
        'Security Type': position.securityType,
        'Security Description': position.securityDescription,
        'Total Market Value': 0,
        'Total Shares': 0,
        'Account Count': 0,
        'Average Price': 0
      });
    }

    const security = securitiesMap.get(symbol);
    security['Total Market Value'] += marketValue;
    security['Total Shares'] += shares;
    security['Account Count'] += 1;
    security['Average Price'] = security['Total Shares'] > 0 ?
      security['Total Market Value'] / security['Total Shares'] : 0;

    // Accounts analysis
    if (!accountsMap.has(accountNumber)) {
      accountsMap.set(accountNumber, {
        'Account Number': accountNumber,
        'Account Name': position.accountName,
        'Total Positions': 0,
        'Total Market Value': 0,
        'Unique Securities': new Set()
      });
    }

    const account = accountsMap.get(accountNumber);
    account['Total Positions'] += 1;
    account['Total Market Value'] += marketValue;
    account['Unique Securities'].add(symbol);
  });

  // Convert to arrays and clean up
  const securities = Array.from(securitiesMap.values());
  const accounts = Array.from(accountsMap.values()).map(account => ({
    'Account Number': account['Account Number'],
    'Account Name': account['Account Name'],
    'Total Positions': account['Total Positions'],
    'Total Market Value': account['Total Market Value'],
    'Unique Securities': account['Unique Securities'].size
  }));

  // Summary statistics
  const totalMarketValue = positionsData.reduce((sum, pos) =>
    sum + (parseFloat(pos.marketValue?.toString() || '0') || 0), 0
  );

  const summary = {
    'Total Positions': positionsData.length,
    'Unique Securities': securitiesMap.size,
    'Unique Accounts': accountsMap.size,
    'Total Market Value': totalMarketValue,
    'Average Position Value': totalMarketValue / positionsData.length,
    'Analysis Date': new Date().toLocaleDateString()
  };

  return {
    securities,
    accounts,
    summary
  };
};